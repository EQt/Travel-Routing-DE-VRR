#!/usr/bin/env perl
## Copyright © 2009 by Daniel Friesel <derf@derf.homelinux.org>
## License: WTFPL <http://sam.zoy.org/wtfpl>
use strict;
use warnings;
use 5.010;
use encoding 'utf8';
use Getopt::Long;
use WWW::Mechanize;

my $firsturl = 'http://efa.vrr.de/vrr/XSLT_TRIP_REQUEST2?language=de&itdLPxx_transpCompany=vrr';
my $posturl = 'http://efa.vrr.de/vrr/XSLT_TRIP_REQUEST2';

my $content;
my %post;
my $www = WWW::Mechanize->new(
	autocheck => 1,
);
my $raw;
my $cons;
my (@from, @to, @via);
my ($time, $time_depart, $time_arrive);
my $date;
my $restrict;
my $prefer;
my $debug = 0;
my $ignore_info = 'Fahrradmitnahme';
my ($i, $j, $con, $part);

$post{type_origin} = 'stop';
$post{type_destination} = 'stop';

sub check_ambiguous($) {
	my $html = shift;
	my $choose_re = qr/<span class="errorTextBold">Bitte auswählen<\/span>/;
	my $select_re = qr/<select name="(?<what>(place|type|name)_(origin|destination))"/;
	my $option_re = qr/<option value="\d+(:\d+)*"( selected)?>(?<choice>[^<]+)<\/option>/;

	if ($html =~ /$choose_re/s) {
		foreach (split(/$choose_re/s, $html)) {
			if (/$select_re/) {
				print "Ambiguous input for $+{what}\n";
			}
			while (/$option_re/gs) {
				print "\t$+{choice}\n";
			}
		}
		return(1);
	}
	return(0);
}

sub parse_content($) {
	my $raw = shift;
	my $groupsize = 8;
	my $offset;
	my $return;
	my @extra;
	for (my $offer = 0; exists($raw->[$offer]); $offer++) {
		foreach (@{$raw->[$offer]}) {
			s/\s*<br>\s*/, /g;
			s/<[^>]+>//g;
		}
		for (my $i = 0; @{$raw->[$offer]} >= (($i+1) * $groupsize); $i++) {
			$offset = $i * $groupsize;
			undef(@extra);
			for my $j (0, 4, 8) {
				until (not exists($raw->[$offer]->[$offset+$j]) or $raw->[$offer]->[$offset+$j] =~ /^\d+:\d+$/) {
					last unless (exists($raw->[$offer]->[$offset+$j]));
					last if ($raw->[$offer]->[$offset+$j] eq 'Verspätungen sind berücksichtigt');
					if ($raw->[$offer]->[$offset+$j] =~ /^\s*$/) {
						splice(@{$raw->[$offer]}, $offset+$j, 1);
					} else {
						push(@extra, splice(@{$raw->[$offer]}, $offset+$j, 1));
					}
				}
			}
			$return->[$offer]->[$i] = {
				deptime  => $raw->[$offer]->[$offset],
				dep      => $raw->[$offer]->[$offset+1],
				depstop  => $raw->[$offer]->[$offset+2],
				deptrain => $raw->[$offer]->[$offset+3],
				depdest  => $raw->[$offer]->[$offset+7],
				arrtime  => $raw->[$offer]->[$offset+4],
				arr      => $raw->[$offer]->[$offset+5],
				arrstop  => $raw->[$offer]->[$offset+6],
			};
			@{$return->[$offer]->[$i]->{extra}} = @extra;
		}
	}
	return($return);
}

sub prepare_content($) {
	my $html = shift;
	my $offer = 0;
	my $return;
	# beware of the no-break space (U+00A0)     ↓     ↓
	foreach (split(/<span class="labelTextBold"> \d+\. Fahrt<\/span>/, $html)) {
		unless ($offer) {
			$offer++;
			next;
		}
		foreach(split(/\n/)) {
			if (/<span class="labelText"( valign="center")?>(?<content>.+)<\/span><\/td>/) {
				push(@{$return->[$offer-1]}, $+{content});
			}
		}
		$offer++;
	}
	return($return);
}

GetOptions(
	'arrive=s'  => \$time_arrive,
	'date=s'    => \$date,
	'debug'     => \$debug,
	'depart=s'  => \$time_depart,
	'from=s{2}' => \@from,
	'help'      => sub {exec('perldoc', $0)},
	'ignore-info=s' => \$ignore_info,
	'post=s'    => \%post,
	'prefer=s'  => \$prefer,
	'restrict=s' => \$restrict,
	'time=s'    => \$time,
	'to=s{2}'   => \@to,
	'via=s{2}'  => \@via,
);

unless (@from and @to) {
	if (@ARGV == 4) {
		(@from[0,1], @to[0,1]) = @ARGV;
	} elsif (@ARGV == 6) {
		(@from[0,1], @via[0,1], @to[0,1]) = @ARGV;
	}
}

unless (@to == 2 and @from == 2) {
	print STDERR "Usage: efa --from <city> <stop> --to <city> <stop> [other options]\n";
	exit(1);
}

@post{'place_origin','name_origin'} = @from;
@post{'place_destination','name_destination'} = @to;
if (@via == 2) {
	@post{'place_via','name_via'} = @via;
}

if ($time_arrive) {
	$time = $time_arrive;
	$post{itdTripDateTimeDepArr} = 'arr';
} elsif ($time_depart) {
	$time = $time_depart;
	$post{itdTripDateTimeDepArr} = 'dep';
}

if ($time) {
	@post{'itdTimeHour','itdTimeMinute'} = split(/:/, $time);
}
if ($date) {
	@post{'itdDateDay','itdDateMonth','itdDateYear'} = split(/\./, $date);
}

if ($prefer) {
	given($prefer) {
		when('speed') { $post{routeType} = 'LEASTTIME' }
		when('nowait') { $post{routeType} = 'LEASTINTERCHANGE' }
		when('nowalk') { $post{routeType} = 'LEASTWALKING' }
		default {
			print STDERR "--prefer usage: speed / nowait / nowalk\n";
		}
	}
}

if ($restrict) {
	given ($restrict) {
		when('local') { $post{lineRestriction} = 403 }
		when('ic')    { $post{lineRestriction} = 401 }
		when('ice')   { $post{lineRestriction} = 400 }
		when(/\d+/)   { $post{lineRestriction} = $restrict }
		default {
			print STDERR "--restrict usage: local / ic / ice\n";
		}
	}
}

$www->get($firsturl);
$www->submit_form(
	form_name => 'jp',
	fields => \%post,
);
$content = $www->content;

if (check_ambiguous($content)) {
	exit(1);
}

$raw = prepare_content($content);

if ($debug) {
	print STDERR "custom post values used in query:\n";
	foreach(keys(%post)) {
		print STDERR "    $_ => $post{$_}\n";
	}
	print STDERR "\nraw response:\n";
	foreach(@$raw) {
		print STDERR "---\n";
		foreach(@$_) {
			print STDERR "$_\n";
		}
	}
}

$cons = parse_content($raw);

for ($i = 0; $con = $cons->[$i]; $i++) {
	for ($j = 0; $part = $con->[$j]; $j++) {
		foreach (@{$part->{extra}}) {
			unless (length($ignore_info) and $_ =~ /$ignore_info/i) {
				print "# $_\n";
			}
		}
		printf(
			"%-5s %-2s %-30s %-20s %s\n%-5s %-2s %-30s\n\n",
			$part->{deptime}, $part->{dep}, $part->{depstop}, $part->{deptrain},
			$part->{depdest}, $part->{arrtime}, $part->{arr}, $part->{arrstop}
		);
	}
	if (defined($cons->[$i+1])) {
		print "------\n\n";
	}
}

__END__

=head1 NAME

efa - unofficial efa.vrr.de command line client

=head1 SYNOPSIS

=over

=item B<efa> B<--from> I<city> I<stop> B<--to> I<city> I<stop> [ I<additional options> ]

=item B<efa> [ I<options> ] I<from-city> I<from-stop> [ I<via-city> I<via-stop> ] I<to-city> I<to-stop>

=back

=head1 DESCRIPTION

B<efa> is a command line client for the L<http://efa.vrr.de> web interface.
It sends the specified information to the online form and displays the results

=head1 OPTIONS

=over

=item B<--from> I<city> I<stop> (mandatory)

Departure place

=item B<--to> I<city> I<stop> (mandatory)

Arrival place

=item B<--via> I<city> I<stop>

Travel via this place

=item B<--time>|B<--depart> I<hh>:I<mm>

Journey start time

=item B<--arrive> I<hh>:I<mm>

Journey end time (overrides --time/--depart)

=item B<--date> I<dd>.I<mm>.I<yyyy>

Journey date

=item B<--prefer> I<type>

Prefer connections of I<type>:

=over

=item * speed (default)

The faster, the better

=item * nowait

Prefer connections with less interchanges

=item * nowalk

Prefer connections with less walking (at interchanges)

=back

=item B<--restrict> I<type>

Only accept connections using trains of type I<type>, where I<type> may be:

=over

=item * local (default)

only take local trains ("Verbund-/Nahverkehrslinien"). Slow, but the cheapest
method if you're not travelling long distance

=item * ic

All trains except ICE

=item * ice

All trains

=back

=item B<--ignore-info> I<regex>

Ignore additional information matching I<regex> (default: /Fahrradmitnahme/)

=item B<--debug>

Display debug information (additional post requests sent to the site,
raw items received from the site)

=item B<--post> I<key>=I<value>

Add I<key> with I<value> to the HTTP POST request sent to the EFA server.
This can be used to use setting B<efa> does not yet cover, like
C<--post lineRestriction=400> to also show IC and ICE trains.
Note that B<--post> will be overridden by the standard efa options, such as
B<--time>.

=back
